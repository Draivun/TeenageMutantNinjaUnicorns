<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEENAGE MUTANT NINJA TURTLE: Technical documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="unicorn supreme2_1.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEENAGE MUTANT NINJA TURTLE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Technical documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="typedefs"></a>
The self new types</h1>
<p>We have 4 typedefs. Two of them are for the objectes and the other 2 are for sactions and collisions. These typedefs make sure we dont have to repeat the same complicated types over and over again. Also the chance of making a mistake is far less with the more easy names we gave our typedefs. The first typedef is called <a class="el" href="drawable_8hpp.html#aab5add95f06d2ba25dbfed8eb07274fa" title="A shared pointer to a drawable object that is re-usable. ">object_ptr</a>. This is a std::shared_ptr type to make sure multiple pointers to the same object can exist without any chance of not destructings the actual item propperly. This shared pointer is of type drawable so we can use it with the objects we want on screen. The second typedef is a std::vector with those object_ptrs as type. It is called <a class="el" href="drawable_8hpp.html#a6c0fdb1dfd0c34dbbdbb5dcd3c608b07" title="A std::vector with object_ptr. ">objects_vector</a>. This is the vector type we put all the objects in so we can loop through them and do what we need to do. We also have a typedef with <a class="el" href="drawable_8hpp.html#a7e1a7f34f6d09dabb4cdafd6e4118603" title="A std::vector with colision objects. ">collisions</a>. In this typedef we put <a class="el" href="structcollision.html" title="a collision ">collision</a> structs with all the collisions any objects has. The last one is for saving a number of actions for the objects you make. It is called <a class="el" href="drawable_8hpp.html#a38f93e4749e0d65d51360c429766d212" title="A std::vector with action objects. ">actions</a>.</p>
<h1><a class="anchor" id="drawable"></a>
The drawable superclass</h1>
<p>The superclass drawable is the main class for all objects that will be shown on the window. it contains therefor only virtual functions. the <a class="el" href="classdrawable.html#a4e49e2c1121704c83ce24c5f48dd910f" title="virtual draw function for a drawable ">drawable::draw()</a> function is de virtual function for drawing a object on a window, further it contains a <a class="el" href="classdrawable.html#ad0d3930c045cc6776aa2c3965be32491" title="Move function for a drawable. ">drawable::move(sf::Vector2f delta)</a> function that in default moves the position with delta. For finding out if a drawable object is in collsion with a other drawable object there is a collapse function this function calculates if one of the outherlines are crossing with a outherline of the other drawable if so there is collision found and the side of collsion will be put in a struct called <a class="el" href="structcollision.html" title="a collision ">collision</a>. For calculating if a outherline is crossing the other outherline the class contains the <a class="el" href="classdrawable.html#a0d3278e4e888fc8289468e8893dd8329" title="check x between a and b ">drawable::within()</a> and the <a class="el" href="classdrawable.html#ab5c0e1af885f214bc9ef0da47cdb5ac9" title="check all pixels between x and y ">drawable::within_range()</a> function these fucntion looks if a certain point is in a given range. furthermore the class contains two functions : <a class="el" href="classdrawable.html#a2ed0f8bb53f33477f7722efa7bb24583" title="object information as string ">drawable::object_information()</a> and <a class="el" href="classdrawable.html#add3d8569fe2616ae0ed503b19c92c08e" title="object information as string ">drawable::string_from_color()</a>, these functions are for returning the information of the object in a <a href="http://www.cplusplus.com/reference/string/string/string/">std::string</a>.</p>
<h1><a class="anchor" id="images"></a>
The images in the game</h1>
<p>All the images just in the game are shown as object of the image class. the image class has multiple function that can be used. the image class is a inherintance of the drawable class. image uses also a override of the <a class="el" href="classdrawable.html#a4e49e2c1121704c83ce24c5f48dd910f" title="virtual draw function for a drawable ">drawable::draw()</a>. Furthermore the class contains an <a class="el" href="classimage__from__file.html#a43b0d6b11bf46827308e4e6cb7aa8579" title="set size ">image_from_file::set_size()</a> and an <a class="el" href="classimage__from__file.html#a868911f8d541af91290fb8dc56435cd2" title="set position ">image_from_file::set_position()</a> these functions are for setting a new size or position.Finally it contains a function for getting the global bounds called <a class="el" href="classimage__from__file.html#a971a591f906fa5c6e85b4e32cfc3d6a0" title="get objects floatrect ">image_from_file::getGlobalBounds()</a> and an <a class="el" href="classimage__from__file.html#a6561a7e8833e4ca84ba5a31e98802757" title="set the texture rectangle ">image_from_file::setTextureRect()</a> for setting a texture in the image also this function is beeing used for mirroring a image without position change.</p>
<h1><a class="anchor" id="unicorn"></a>
Unicorn</h1>
<p>The unicorn in the game can be created by creating an object of the <a class="el" href="classunicorn.html" title="class that is used to display and control the unicorn ">unicorn</a> class. The image of the unicorn is created by the <a class="el" href="classimage__from__file.html" title="create sprite on screen ">image_from_file</a> class. It also uses the <a class="el" href="classphysics.html" title="Class with physics function. ">physics</a> class to create a more realistic jumping and falling motion. The class dus also inherrit <a class="el" href="classdrawable.html" title="class that is inherited by all objects that are drawable ">drawable</a>. Drawable comes with his predefined funtions that can be used by the unicorn due to the inherritance. The unicorn class also overrides the couple of abstract functions. These functions are <a class="el" href="classdrawable.html#a4e49e2c1121704c83ce24c5f48dd910f" title="virtual draw function for a drawable ">drawable::draw()</a>, <a class="el" href="classdrawable.html#ad0d3930c045cc6776aa2c3965be32491" title="Move function for a drawable. ">drawable::move()</a>, <a class="el" href="classdrawable.html#ac39691470b7874f5dec59efe649d3981" title="virtual draw function for a drawable ">drawable::jump()</a>, <a class="el" href="classdrawable.html#ae013ac0be47538be9ce885d6642daf73" title="virtual getGlobalBounds function ">drawable::getGlobalBounds()</a>, <a class="el" href="classdrawable.html#a715df01a318331e5611a2b0ad30109ff" title="check and execute actions ">drawable::run_actions()</a>, <a class="el" href="classdrawable.html#abbc6e0089d502ba48c3fcb9c96e3966e" title="check for collisions ">drawable::check_for_collisions</a>. The <a class="el" href="classunicorn.html#a570c34d5669a8d2a61bdc1481e6f9dee" title="function that draws the image ">unicorn::draw()</a> function first checks if the direction the unicorn is facing is correct. If it is not, the unicorn is turned around. After that either the <a class="el" href="classphysics.html#aaf1c57aa6e35b9c83ccbfdfa8c18468c" title="The working function for jumping. ">physics::jumping()</a> function is called to move the unicorn up or the <a class="el" href="classphysics.html#acca1ee2fb8b760b6e4ee61ae7c2ee3da" title="the working function that contains the gavity. ">physics::falling()</a> function is called to move the unicorn down. There is one exception to both, the unicorn dus not fall if he is on the ground and the unicorn also dus not go up when something is above him. The <a class="el" href="classunicorn.html#a162f200a68342f7bc0baaf17c8cf3f9f" title="function that moves image object with a certian delta ">unicorn::move()</a> function moves the unicorn right and left unless there is a collision on the side he is trying to move to. The <a class="el" href="classunicorn.html#a07d5ca4e66632c0e871221a27146805a" title="let the unicorn jump ">unicorn::jump()</a> function sets the counter for jumping to 25 so it can be counted down to 3 in the draw function. These values seemed to give us the most realistic jumping effect This counter is used to calculate the speed with wich the unicorn goes up in the <a class="el" href="classphysics.html#aaf1c57aa6e35b9c83ccbfdfa8c18468c" title="The working function for jumping. ">physics::jumping()</a> function. It dus not do this when he is not on the ground or when the counter is not 0. This way dubble jumping is impossible. <a class="el" href="classunicorn.html#a1bac09fc59b04f14f5a093bc4daa04da" title="function that gets the boundingbox of the image ">unicorn::getGlobalBounds()</a> returns the global bounds of the image. These global bounds can be used for collision detection. The <a class="el" href="classunicorn.html#aadb47a9981c46d6add8704074df117df" title="functions that runs through all actions related to the unicorn ">unicorn::run_actions()</a> function goes through the list of actions. It calls the <a class="el" href="classaction.html#a92c003677656b5b3e6e58b19376e6b04" title="operator() ">action::operator()()</a> from the <a class="el" href="classaction.html" title="actions that a charater can do ">action</a> class on all the actions and the rest is handled by the operator() function.</p>
<h1><a class="anchor" id="wall"></a>
The walls of the game</h1>
<p>The wall creates a rectangle on the screen on specified position and with a specified size. The color of the wall can also be set to an initial color. The class inherrits <a class="el" href="classdrawable.html" title="class that is inherited by all objects that are drawable ">drawable</a> to be able to use all its functionality. The functions from drawable that are redefined here are: <a class="el" href="classdrawable.html#a4e49e2c1121704c83ce24c5f48dd910f" title="virtual draw function for a drawable ">drawable::draw()</a>, <a class="el" href="classdrawable.html#ae013ac0be47538be9ce885d6642daf73" title="virtual getGlobalBounds function ">drawable::getGlobalBounds()</a>, <a class="el" href="classdrawable.html#a2ed0f8bb53f33477f7722efa7bb24583" title="object information as string ">drawable::object_information()</a>. The <a class="el" href="classwall.html#aa25b8377e1d9a209fabd2271294f05d0" title="Draw function for the wall. ">wall::draw()</a> function draws the object and sets the color and position. The <a class="el" href="classwall.html#a317a464c879cfdf9464bd6f1b62d9101" title="Function that gives de global bounds. ">wall::getGlobalBounds()</a> function returns the global bounds of the rectangle. The <a class="el" href="classwall.html#aab1de4f144f176b134a967ba08747932" title="Funtion that returns object information. ">wall::object_information()</a> function returns the information of the object as <a href="http://www.cplusplus.com/reference/string/string/string/">std::string</a>. This includes the size and the color. The rest of the information comes from the <a class="el" href="classdrawable.html#a2ed0f8bb53f33477f7722efa7bb24583" title="object information as string ">drawable::object_information()</a> function.</p>
<h1><a class="anchor" id="actions"></a>
The actions for the different objects</h1>
<p>The <a class="el" href="classaction.html" title="actions that a charater can do ">action</a> class is a class made for handeling in game actions it contains couple of different constructors that are made for different actions. for using keybaord and mousse there are two different constructors and there is a constructor that can be used in a template way where if parameter 1 gives true the function given in parameter number 2 will be runt.</p>
<h1><a class="anchor" id="animation"></a>
the animation in the game</h1>
<p>the animation class is the class that makes the objects in the game have animations like walking around and loop when jumping the way the animations work is a big picture with multiple states on it in which the program will loop in and making the walk movement or other movement in which the sheet is set. One sheet contains multiple rows with multiple lines each line is one animation and some animations are made bij using <a href="https://www.sfml-dev.org/documentation/2.0/classsf_1_1Sprite.php">sf::sprite</a> functions like<a href="https://www.sfml-dev.org/documentation/2.0/classsf_1_1Transformable.php#a32baf2bf1a74699b03bf8c95030a38ed">sf::sprite::setRotation</a> and<a href="https://www.sfml-dev.org/documentation/2.0/classsf_1_1Transformable.php#aa93a835ffbf3bee2098dfbbc695a7f05">sf::sprite::setOrigin</a> for the jump. By resetting the origin to position 0.5*size the rotation will be in the middle of the certain object. And after that replacing the origin to the position which makes it turn around the mid without teleport like bugs.</p>
<h1><a class="anchor" id="physics"></a>
The game's physics</h1>
<p>The action class is a class that contains the needed functions for making movement in the game feel natural. for jumping there is the <a class="el" href="classphysics.html#aaf1c57aa6e35b9c83ccbfdfa8c18468c" title="The working function for jumping. ">physics::jumping()</a> function and for the grafity there is the <a class="el" href="classphysics.html#acca1ee2fb8b760b6e4ee61ae7c2ee3da" title="the working function that contains the gavity. ">physics::falling()</a> function.</p>
<h1><a class="anchor" id="background"></a>
The background of the game</h1>
<p>The background of the game. the background creates a sprite that is covered troughout the gamefield creating a background for the game. the background is een inheratance of the <a class="el" href="classdrawable.html" title="class that is inherited by all objects that are drawable ">drawable</a> class and uses the <a class="el" href="classdrawable.html#a4e49e2c1121704c83ce24c5f48dd910f" title="virtual draw function for a drawable ">drawable::draw()</a> function for drawing the background. the background class contains a image object where the background is in.</p>
<h1><a class="anchor" id="camera"></a>
The player folowing camera</h1>
<p>The camera class has one thing to do and has also only one function and that is following a object of the <a class="el" href="classunicorn.html" title="class that is used to display and control the unicorn ">unicorn</a> class.</p>
<h1><a class="anchor" id="sound"></a>
The sound in the games</h1>
<p>the soundtrack class is the class that handles the background music in this class is set the sound file by setting the music in the constructor and playing it by the <a class="el" href="classsoundtrack.html#a7569a4c0cde86548197756b8e05cf464" title="Music player. ">soundtrack::playmusic()</a> function.</p>
<h1><a class="anchor" id="base_level"></a>
The level boundary's</h1>
<p>Every level gets level boundary's. These boundary's are based on the level size read by the <a class="el" href="classfactory.html" title="Factory for reading in levels. ">factory</a> from the level files. These boundary's are made transparent. They are also created with a offset to make sure the borders are not in the upper left corner of the background. This way you do not see a partially black background. These level boundary's can be put into a objects vector by calling the <a class="el" href="classbase__level.html#a3b2da28cf45cad434103e81ee6c4538d" title="Put walls in the walls vector. ">base_level::push_back_borders()</a> function from the class and giving it the vector you want to put them in as parameter.</p>
<h1><a class="anchor" id="factory"></a>
Reading files with the factory</h1>
<p>The factory can be used to read out level files. An example of a level file is the following:</p>
<p>SPAWN (1030,1500).<br />
 LEVEL_SIZE (4000,3350).<br />
 WALL (1020.000000,2000.000000) (100.000000,20.000000) green grass.png.<br />
 WALL (1499.824341,2133.414062) (100.000000,20.000000) green grass.png</p>
<p>The first two lines are always neccesary because the level wil not have a correct size or a spawn point without them. The rest can be customized to what level you want. In The factory there are 6 functions. The first one is called <a class="el" href="classfactory.html#a9e164a8fbb65188de99c39d55d7cc384" title="Change the input. ">factory::change_input_to()</a> and is used to change the input file. If a file is already open it closes that file first. The second and third are used to read lines from the input file. They are called <a class="el" href="classfactory.html#a82385866bc910c1b3a3e82d56487dd24" title="Read one line from the filestream. ">factory::read_line()</a> and <a class="el" href="classfactory.html#afb2fad4ac9b0f39b1bfc3f3fc8d218b6" title="Read multiple objects. ">factory::objects_from_file()</a>. The read line function reads a single line and returnes an <a class="el" href="drawable_8hpp.html#aab5add95f06d2ba25dbfed8eb07274fa" title="A shared pointer to a drawable object that is re-usable. ">object_ptr</a> to the newly created object or an error of different types if something went wrong. The objects from file function handles all the errors and puts the objects in an <a class="el" href="drawable_8hpp.html#a6c0fdb1dfd0c34dbbdbb5dcd3c608b07" title="A std::vector with object_ptr. ">objects_vector</a>. This vector is returned. The next function is called <a class="el" href="classfactory.html#af17f2a44d75cf8ccf712384341c2fcde" title="Write information to file. ">factory::write_information_to_file()</a> and writes all the information about objects to a file. This repeatedly calles the <a class="el" href="classdrawable.html#a2ed0f8bb53f33477f7722efa7bb24583" title="object information as string ">drawable::object_information()</a> function after the spawn and level size ar already put into the file. The last two functions are for getting the level size and the spawn location from the factory. The names for these functions are <a class="el" href="classfactory.html#a3c3a039b8f76a947267dbe659166550b" title="Get spawn location. ">factory::get_spawn()</a> and <a class="el" href="classfactory.html#af9bb026273b34fc032ca5ac73d457611" title="Get the level size. ">factory::get_level_size()</a>.</p>
<h1><a class="anchor" id="bullet"></a>
Shooting feature</h1>
<p>The bullet class is used to move a <a class="el" href="classimage__from__file.html" title="create sprite on screen ">image_from_file</a> object (in this game Nyan-Cat.png) a amount of spots. When the bullet animation collides (this is checked with <a class="el" href="classbullet.html#ab7e5c677bbd642df24a2251bb58249b7" title="function that checks collision with pointer ">bullet::collision()</a>) with either a wall or a mob the bullet is reset and not drawn until it is fired agian. With <a class="el" href="classunicorn.html#af448a3fa5fc5f09254b50afa151ce42b" title="function that shoots bullet ">unicorn::shoot()</a> the bullet is activated.</p>
<h1><a class="anchor" id="mob"></a>
Enemy creatures</h1>
<p>The mob class is used to display an enemy. When <a class="el" href="classmob.html#ac524dd40986df00721239b66c552437e" title="constructor to initialize mob ">mob::mob()</a> is called the mob is always alive. When <a class="el" href="classmob.html#ae892b3ce84f4aa16411b385abb5410c8" title="function that sets boolean ">mob::die()</a> is called the mob dies and the variable alive is set to false , this means it isn't drawn anymore and has a empty global bounds . The global bounds is empty to make sure the bullet goes through the mob when it has died. <a class="el" href="classmob.html#a3bce6c06653881f8be86fbc60a2b67cb" title="function that sets boolean ">mob::revive()</a> can be used to set the variable alive to true</p>
<h1><a class="anchor" id="menu"></a>
The menu's</h1>
<p>The main menu consists mainly of 2 parts. First , the background image. This is an object of the <a class="el" href="classbackground.html" title="Class that draws a background. ">background</a> class. This sets the background sprite with the specified image. Second, the buttons that make up the menu. The main menu consists of three buttons, these are <a class="el" href="class_button.html" title="Creates a button at a specific place on the screen. ">Button</a> objects. Together they make up the visual aspect of the menu. The clickable part is handled in <a class="el" href="classmenu.html#a06744d58a2aad693d3637d0485aa7984" title="Function that handles the pushable part of the button. ">menu::select()</a>, where the collision detection <a href="https://www.sfml-dev.org/documentation/2.0/classsf_1_1Rect.php#aa8a5364c84de6dd5299f833b54e31ef1">SFML rect::contains()</a>.triggers if the button is clicked with the cursor ( left mouse button ).</p>
<h1><a class="anchor" id="Button"></a>
The buttons</h1>
<p>The buttons are made specifically tailored for our game. The buttons are all customizable, background is easy to change as is the font.</p>
<p>All the math in this class is done to make sure the buttons are aligned <br />
 in the middle of the screen, regardless of resolution. However, SFML does not have a native <br />
 rescale of pictures in sprites. Which means that the background of the buttons will be completely distorted in some resolutions. Also, a lot of this math could be moved to the <a class="el" href="classmenu.html" title="Creates a menu with up to 3 buttons. ">menu</a> class, which would make the <a class="el" href="class_button.html" title="Creates a button at a specific place on the screen. ">Button</a> class more re-useable. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
