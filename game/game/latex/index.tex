\hypertarget{index_typedefs}{}\section{The self new types}\label{index_typedefs}
We have 4 typedefs. Two of them are for the objectes and the other 2 are for sactions and collisions. These typedefs make sure we dont have to repeat the same complicated types over and over again. Also the chance of making a mistake is far less with the more easy names we gave our typedefs. The first typedef is called \hyperlink{typedefs_8hpp_aab5add95f06d2ba25dbfed8eb07274fa}{object\+\_\+ptr}. This is a std\+::shared\+\_\+ptr type to make sure multiple pointers to the same object can exist without any chance of not destructings the actual item propperly. This shared pointer is of type drawable so we can use it with the objects we want on screen. The second typedef is a std\+::vector with those object\+\_\+ptrs as type. It is called \hyperlink{typedefs_8hpp_a6c0fdb1dfd0c34dbbdbb5dcd3c608b07}{objects\+\_\+vector}. This is the vector type we put all the objects in so we can loop through them and do what we need to do. We also have a typedef with \hyperlink{typedefs_8hpp_a7e1a7f34f6d09dabb4cdafd6e4118603}{collisions}. In this typedef we put \hyperlink{structcollision}{collision} structs with all the collisions any objects has. The last one is for saving a number of actions for the objects you make. It is called \hyperlink{typedefs_8hpp_a38f93e4749e0d65d51360c429766d212}{actions}.\hypertarget{index_drawable}{}\section{The drawable superclass}\label{index_drawable}
The superclass drawable is the main class for all objects that will be shown on the window. it contains therefor only virtual functions. the \hyperlink{classdrawable_a4e49e2c1121704c83ce24c5f48dd910f}{drawable\+::draw()} function is de virtual function for drawing a object on a window, further it contains a \hyperlink{classdrawable_ad0d3930c045cc6776aa2c3965be32491}{drawable\+::move(sf\+::\+Vector2f delta)} function that in default moves the position with delta. For finding out if a drawable object is in collsion with a other drawable object there is a collapse function this function calculates if one of the outherlines are crossing with a outherline of the other drawable if so there is collision found and the side of collsion will be put in a struct called \hyperlink{structcollision}{collision}. For calculating if a outherline is crossing the other outherline the class contains the \hyperlink{classdrawable_a0d3278e4e888fc8289468e8893dd8329}{drawable\+::within()} and the \hyperlink{classdrawable_ab5c0e1af885f214bc9ef0da47cdb5ac9}{drawable\+::within\+\_\+range()} function these fucntion looks if a certain point is in a given range. furthermore the class contains two functions \+: \hyperlink{classdrawable_a2ed0f8bb53f33477f7722efa7bb24583}{drawable\+::object\+\_\+information()} and \hyperlink{classdrawable_add3d8569fe2616ae0ed503b19c92c08e}{drawable\+::string\+\_\+from\+\_\+color()}, these functions are for returning the information of the object in a \href{http://www.cplusplus.com/reference/string/string/string/}{\tt std\+::string}.\hypertarget{index_images}{}\section{The images in the game}\label{index_images}
All the images just in the game are shown as object of the image class. the image class has multiple function that can be used. the image class is a inherintance of the drawable class. image uses also a override of the \hyperlink{classdrawable_a4e49e2c1121704c83ce24c5f48dd910f}{drawable\+::draw()}. Furthermore the class contains an \hyperlink{classimage__from__file_a43b0d6b11bf46827308e4e6cb7aa8579}{image\+\_\+from\+\_\+file\+::set\+\_\+size()} and an \hyperlink{classimage__from__file_a868911f8d541af91290fb8dc56435cd2}{image\+\_\+from\+\_\+file\+::set\+\_\+position()} these functions are for setting a new size or position.\+Finally it contains a function for getting the global bounds called \hyperlink{classimage__from__file_a971a591f906fa5c6e85b4e32cfc3d6a0}{image\+\_\+from\+\_\+file\+::get\+Global\+Bounds()} and an \hyperlink{classimage__from__file_a6561a7e8833e4ca84ba5a31e98802757}{image\+\_\+from\+\_\+file\+::set\+Texture\+Rect()} for setting a texture in the image also this function is beeing used for mirroring a image without position change.\hypertarget{index_unicorn}{}\section{Unicorn}\label{index_unicorn}
The unicorn and it\textquotesingle{}s rainbow in the game acan be created by creating an object of the \hyperlink{classunicorn}{unicorn} class. Rainbow get\textquotesingle{}s it\textquotesingle{}s location by using the location of the unicorn in combination with the location of the window. The image of the unicorn and of the rainbow are created by the \hyperlink{classimage__from__file}{image\+\_\+from\+\_\+file} class. the unicorn also uses the \hyperlink{classphysics}{physics} class to create a more realistic jumping and falling motion. The class dus also inherrit \hyperlink{classdrawable}{drawable}. Drawable comes with his predefined funtions that can be used by the unicorn due to the inherritance. The unicorn class also overrides the couple of abstract functions. These functions are \hyperlink{classdrawable_a4e49e2c1121704c83ce24c5f48dd910f}{drawable\+::draw()}, \hyperlink{classdrawable_ad0d3930c045cc6776aa2c3965be32491}{drawable\+::move()}, \hyperlink{classdrawable_ac39691470b7874f5dec59efe649d3981}{drawable\+::jump()}, \hyperlink{classdrawable_ae013ac0be47538be9ce885d6642daf73}{drawable\+::get\+Global\+Bounds()}, \hyperlink{classdrawable_a715df01a318331e5611a2b0ad30109ff}{drawable\+::run\+\_\+actions()}, \hyperlink{classdrawable_abbc6e0089d502ba48c3fcb9c96e3966e}{drawable\+::check\+\_\+for\+\_\+collisions}. The \hyperlink{classunicorn_a570c34d5669a8d2a61bdc1481e6f9dee}{unicorn\+::draw()} function first checks if the direction the unicorn is facing is correct. If it is not, the unicorn is turned around. After that either the \hyperlink{classphysics_aaf1c57aa6e35b9c83ccbfdfa8c18468c}{physics\+::jumping()} function is called to move the unicorn up or the \hyperlink{classphysics_acca1ee2fb8b760b6e4ee61ae7c2ee3da}{physics\+::falling()} function is called to move the unicorn down. There is one exception to both, the unicorn dus not fall if he is on the ground and the unicorn also dus not go up when something is above him. The \hyperlink{classunicorn_a162f200a68342f7bc0baaf17c8cf3f9f}{unicorn\+::move()} function moves the unicorn right and left unless there is a collision on the side he is trying to move to. The \hyperlink{classunicorn_a07d5ca4e66632c0e871221a27146805a}{unicorn\+::jump()} function sets the counter for jumping to 25 so it can be counted down to 3 in the draw function. These values seemed to give us the most realistic jumping effect This counter is used to calculate the speed with wich the unicorn goes up in the \hyperlink{classphysics_aaf1c57aa6e35b9c83ccbfdfa8c18468c}{physics\+::jumping()} function. It dus not do this when he is not on the ground or when the counter is not 0. This way dubble jumping is impossible. \hyperlink{classunicorn_a1bac09fc59b04f14f5a093bc4daa04da}{unicorn\+::get\+Global\+Bounds()} returns the global bounds of the image. These global bounds can be used for collision detection. The \hyperlink{classunicorn_aadb47a9981c46d6add8704074df117df}{unicorn\+::run\+\_\+actions()} function goes through the list of actions. It calls the \hyperlink{classaction_a92c003677656b5b3e6e58b19376e6b04}{action\+::operator()()} from the \hyperlink{classaction}{action} class on all the actions and the rest is handled by the operator() function.\hypertarget{index_wall}{}\section{The walls of the game}\label{index_wall}
The wall creates a rectangle on the screen on specified position and with a specified size. The color of the wall can also be set to an initial color. The class inherrits \hyperlink{classdrawable}{drawable} to be able to use all its functionality. The functions from drawable that are redefined here are\+: \hyperlink{classdrawable_a4e49e2c1121704c83ce24c5f48dd910f}{drawable\+::draw()}, \hyperlink{classdrawable_ae013ac0be47538be9ce885d6642daf73}{drawable\+::get\+Global\+Bounds()}, \hyperlink{classdrawable_a2ed0f8bb53f33477f7722efa7bb24583}{drawable\+::object\+\_\+information()}. The \hyperlink{classwall_aa25b8377e1d9a209fabd2271294f05d0}{wall\+::draw()} function draws the object and sets the color and position. The \hyperlink{classwall_a317a464c879cfdf9464bd6f1b62d9101}{wall\+::get\+Global\+Bounds()} function returns the global bounds of the rectangle. The \hyperlink{classwall_aab1de4f144f176b134a967ba08747932}{wall\+::object\+\_\+information()} function returns the information of the object as \href{http://www.cplusplus.com/reference/string/string/string/}{\tt std\+::string}. This includes the size and the color. The rest of the information comes from the \hyperlink{classdrawable_a2ed0f8bb53f33477f7722efa7bb24583}{drawable\+::object\+\_\+information()} function.\hypertarget{index_actions}{}\section{The actions for the different objects}\label{index_actions}
The \hyperlink{classaction}{action} class is a class made for handeling in game actions it contains couple of different constructors that are made for different actions. for using keybaord and mousse there are two different constructors and there is a constructor that can be used in a template way where if parameter 1 gives true the function given in parameter number 2 will be runt.\hypertarget{index_animation}{}\section{the animation in the game}\label{index_animation}
the animation class is the class that makes the objects in the game have animations like walking around and loop when jumping the way the animations work is a big picture with multiple states on it in which the program will loop in and making the walk movement or other movement in which the sheet is set. One sheet contains multiple rows with multiple lines each line is one animation and some animations are made bij using \href{https://www.sfml-dev.org/documentation/2.0/classsf_1_1Sprite.php}{\tt sf\+::sprite} functions like\href{https://www.sfml-dev.org/documentation/2.0/classsf_1_1Transformable.php#a32baf2bf1a74699b03bf8c95030a38ed}{\tt sf\+::sprite\+::set\+Rotation} and\href{https://www.sfml-dev.org/documentation/2.0/classsf_1_1Transformable.php#aa93a835ffbf3bee2098dfbbc695a7f05}{\tt sf\+::sprite\+::set\+Origin} for the jump. By resetting the origin to position 0.\+5$\ast$size the rotation will be in the middle of the certain object. And after that replacing the origin to the position which makes it turn around the mid without teleport like bugs.\hypertarget{index_physics}{}\section{The game\textquotesingle{}s physics}\label{index_physics}
The action class is a class that contains the needed functions for making movement in the game feel natural. for jumping there is the \hyperlink{classphysics_aaf1c57aa6e35b9c83ccbfdfa8c18468c}{physics\+::jumping()} function and for the grafity there is the \hyperlink{classphysics_acca1ee2fb8b760b6e4ee61ae7c2ee3da}{physics\+::falling()} function.\hypertarget{index_background}{}\section{The background of the game}\label{index_background}
The background of the game. the background creates a sprite that is covered troughout the gamefield creating a background for the game. the background is een inheratance of the \hyperlink{classdrawable}{drawable} class and uses the \hyperlink{classdrawable_a4e49e2c1121704c83ce24c5f48dd910f}{drawable\+::draw()} function for drawing the background. the background class contains a image object where the background is in.\hypertarget{index_camera}{}\section{The player folowing camera}\label{index_camera}
The camera class has one thing to do and has also only one function and that is following a object of the \hyperlink{classunicorn}{unicorn} class.\hypertarget{index_sound}{}\section{The sound in the games}\label{index_sound}
the soundtrack class is the class that handles the background music in this class is set the sound file by setting the music in the constructor and playing it by the playmusic function.\hypertarget{index_base_level}{}\section{The level boundary\textquotesingle{}s}\label{index_base_level}
Every level gets level boundary\textquotesingle{}s. These boundary\textquotesingle{}s are based on the level size read by the \hyperlink{classfactory}{factory} from the level files. These boundary\textquotesingle{}s are made transparent. They are also created with a offset to make sure the borders are not in the upper left corner of the background. This way you do not see a partially black background. These level boundary\textquotesingle{}s can be put into a objects vector by calling the \hyperlink{classbase__level_a3b2da28cf45cad434103e81ee6c4538d}{base\+\_\+level\+::push\+\_\+back\+\_\+borders()} function from the class and giving it the vector you want to put them in as parameter.\hypertarget{index_factory}{}\section{Reading files with the factory}\label{index_factory}
The factory can be used to read out level files. An example of a level file is the following\+:

S\+P\+A\+WN (1030,1500).~\newline
 L\+E\+V\+E\+L\+\_\+\+S\+I\+ZE (4000,3350).~\newline
 W\+A\+LL (1020.\+000000,2000.\+000000) (100.\+000000,20.\+000000) green grass.\+png.~\newline
 W\+A\+LL (1499.\+824341,2133.\+414062) (100.\+000000,20.\+000000) green grass.\+png

The first two lines are always neccesary because the level wil not have a correct size or a spawn point without them. The rest can be customized to what level you want. In The factory there are 6 functions. The first one is called \hyperlink{classfactory_a9e164a8fbb65188de99c39d55d7cc384}{factory\+::change\+\_\+input\+\_\+to()} and is used to change the input file. If a file is already open it closes that file first. The second and third are used to read lines from the input file. They are called \hyperlink{classfactory_a82385866bc910c1b3a3e82d56487dd24}{factory\+::read\+\_\+line()} and \hyperlink{classfactory_afb2fad4ac9b0f39b1bfc3f3fc8d218b6}{factory\+::objects\+\_\+from\+\_\+file()}. The read line function reads a single line and returnes an \hyperlink{typedefs_8hpp_aab5add95f06d2ba25dbfed8eb07274fa}{object\+\_\+ptr} to the newly created object or an error of different types if something went wrong. The objects from file function handles all the errors and puts the objects in an \hyperlink{typedefs_8hpp_a6c0fdb1dfd0c34dbbdbb5dcd3c608b07}{objects\+\_\+vector}. This vector is returned. The next function is called \hyperlink{classfactory_af17f2a44d75cf8ccf712384341c2fcde}{factory\+::write\+\_\+information\+\_\+to\+\_\+file()} and writes all the information about objects to a file. This repeatedly calles the \hyperlink{classdrawable_a2ed0f8bb53f33477f7722efa7bb24583}{drawable\+::object\+\_\+information()} function after the spawn and level size ar already put into the file. The last two functions are for getting the level size and the spawn location from the factory. The names for these functions are \hyperlink{classfactory_a3c3a039b8f76a947267dbe659166550b}{factory\+::get\+\_\+spawn()} and \hyperlink{classfactory_af9bb026273b34fc032ca5ac73d457611}{factory\+::get\+\_\+level\+\_\+size()}.\hypertarget{index_bullet}{}\section{Shooting feature}\label{index_bullet}
The bullet class is used to move a \hyperlink{classimage__from__file}{image\+\_\+from\+\_\+file} object (in this game Nyan-\/\+Cat.\+png) a amount of spots. When the bullet animation collides (this is checked with \hyperlink{classbullet_ab7e5c677bbd642df24a2251bb58249b7}{bullet\+::collision()}) with either a wall or a mob the bullet is reset and not drawn until it is fired agian. With \hyperlink{classunicorn_af448a3fa5fc5f09254b50afa151ce42b}{unicorn\+::shoot()} the bullet is activated.\hypertarget{index_mob}{}\section{Enemy creatures}\label{index_mob}
The mob class is used to display an enemy. When \hyperlink{classmob_ac524dd40986df00721239b66c552437e}{mob\+::mob()} is called the mob is always alive. When \hyperlink{classmob_ae892b3ce84f4aa16411b385abb5410c8}{mob\+::die()} is called the mob dies and the variable alive is set to false , this means it isn\textquotesingle{}t drawn anymore and has a empty global bounds . The global bounds is empty to make sure the bullet goes through the mob when it has died. \hyperlink{classmob_a3bce6c06653881f8be86fbc60a2b67cb}{mob\+::revive()} can be used to set the variable alive to true\hypertarget{index_menu}{}\section{The menu\textquotesingle{}s}\label{index_menu}
The main menu consists mainly of 2 parts. First , the background image. This is an object of the \hyperlink{classbackground}{background} class. This sets the background sprite with the specified image. Second, the buttons that make up the menu. The main menu consists of three buttons, these are \hyperlink{class_button}{Button} objects. Together they make up the visual aspect of the menu. The clickable part is handled in \hyperlink{classmenu_a06744d58a2aad693d3637d0485aa7984}{menu\+::select()}, where the collision detection \href{https://www.sfml-dev.org/documentation/2.0/classsf_1_1Rect.php#aa8a5364c84de6dd5299f833b54e31ef1 }{\tt standard S\+F\+ML Rect\+::contains()} triggers if the button is clicked with the cursor ( left mouse button ).\hypertarget{index_Button}{}\section{The buttons}\label{index_Button}
The buttons are made specifically tailored for our game. The buttons are all customizable, background is easy to change as is the font.

All the math in this class is done to make sure the buttons are aligned in the middle of the screen, regardless of resolution. However, S\+F\+ML does not have a native rescale of pictures in sprites. Which means that the background of the buttons will be completely distorted in some resolutions. Also, a lot of this math could be moved to the \hyperlink{classmenu}{menu} class, which would make the \hyperlink{class_button}{Button} class more re-\/useable.\hypertarget{index_menu_management}{}\section{menu\+\_\+management}\label{index_menu_management}
This class is used to manage the different menu\textquotesingle{}s in the game. \hyperlink{classmenu__management_aad6e975e03cab2478f3ebec8da7eaf7d}{menu\+\_\+management\+::display\+\_\+start\+\_\+game()} , \hyperlink{classmenu__management_ab7aa6674e3428604073af06efe5aa791}{menu\+\_\+management\+::display\+\_\+pause\+\_\+game()} , \hyperlink{classmenu__management_ac64c1eace3d955be8623a1129597dc54}{menu\+\_\+management\+::display\+\_\+save\+\_\+file\+\_\+menu()} are functions that can be used to display there respective menu. The function \hyperlink{classmenu__management_a92d22f059d33ccc5c3ae485804fd5fbb}{menu\+\_\+management\+::start\+\_\+game()} combines the start\+\_\+menu and the save\+\_\+file menu. This function returns the path to the level selected by the user\hypertarget{index_file_management}{}\section{file\+\_\+management}\label{index_file_management}
This class is used to manage the different files for the game. With the function \hyperlink{classfile__management_a6c3f90ce958156adea878510097d64ef}{file\+\_\+management\+::get\+\_\+files()} you can get the information from the current file used as input. With \hyperlink{classfile__management_a090d9aba4dd5a795428ccbfe8d4037e6}{file\+\_\+management\+::set\+\_\+input()} you can change the input file. With the function \hyperlink{classfile__management_a97eda13bca5dbe703663bf81f83a77a0}{file\+\_\+management\+::make\+\_\+save\+\_\+file\+\_\+menu()} you can make a menu-\/object that gives the right amount of save files in buttons for the user to click. The function \hyperlink{classfile__management_a79e6ae7cec63aa959d7d0730d6ffa5a3}{file\+\_\+management\+::save\+\_\+game()} can be used to save the game in the current save\+\_\+game file. 