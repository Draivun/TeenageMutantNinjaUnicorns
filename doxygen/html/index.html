<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TEENAGE MUTANT NINJA UNICORN: Technical documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="unicorn supreme2_1.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TEENAGE MUTANT NINJA UNICORN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Technical documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="typedefs"></a>
The self new types</h1>
<p>We have 4 typedefs. Two of them are for the objectes and the other 2 are for actions and collisions. These typedefs make sure we dont have to repeat the same complicated types over and over again. Also the chance of making a mistake is far less with the more easy names we gave our typedefs. The first typedef is called <a class="el" href="typedefs_8hpp.html#aab5add95f06d2ba25dbfed8eb07274fa" title="std::shared_ptr to a drawable object ">object_ptr</a>. This is a std::shared_ptr type to make sure multiple pointers to the same object can exist without any chance of not destructings the actual item propperly. This shared pointer is of type drawable so we can use it with the objects we want on screen. The second typedef is a std::vector with those object_ptrs as type. It is called <a class="el" href="typedefs_8hpp.html#a6c0fdb1dfd0c34dbbdbb5dcd3c608b07" title="std::vector with object_ptr objects ">objects_vector</a>. This is the vector type we put all the objects in so we can loop through them and do what we need to do. We also have a typedef with <a class="el" href="typedefs_8hpp.html#a7e1a7f34f6d09dabb4cdafd6e4118603" title="std::vector with collision objects ">collisions</a>. In this typedef we put <a class="el" href="structcollision.html" title="a collision ">collision</a> structs with all the collisions any objects has. The last one is for saving a number of actions for the objects you make. It is called <a class="el" href="typedefs_8hpp.html#a38f93e4749e0d65d51360c429766d212" title="std::vector with action objects ">actions</a>.</p>
<h1><a class="anchor" id="drawable"></a>
The drawable superclass</h1>
<p>The superclass drawable is the main class for all objects that will be shown on the window. it contains therefor only virtual functions. the <a class="el" href="classdrawable.html#a4e49e2c1121704c83ce24c5f48dd910f" title="virtual draw function for a drawable ">drawable::draw()</a> function is de virtual function for drawing a object on a window, further it contains a <a class="el" href="classdrawable.html#ad0d3930c045cc6776aa2c3965be32491" title="Move function for a drawable. ">drawable::move(sf::Vector2f delta)</a> function that in default moves the position with delta. For finding out if a drawable object is in collsion with a other drawable object there is a collapse function this function calculates if one of the outherlines are crossing with a outherline of the other drawable if so there is collision found and the side of collsion will be put in a struct called <a class="el" href="structcollision.html" title="a collision ">collision</a>. For calculating if a outherline is crossing the other outherline the class contains the <a class="el" href="classdrawable.html#a0d3278e4e888fc8289468e8893dd8329" title="check x between a and b ">drawable::within()</a> and the <a class="el" href="classdrawable.html#ab5c0e1af885f214bc9ef0da47cdb5ac9" title="check all pixels between x and y ">drawable::within_range()</a> function these fucntion looks if a certain point is in a given range. furthermore the class contains two functions : <a class="el" href="classdrawable.html#a2ed0f8bb53f33477f7722efa7bb24583" title="object information as string ">drawable::object_information()</a> and <a class="el" href="classdrawable.html#add3d8569fe2616ae0ed503b19c92c08e" title="object information as string ">drawable::string_from_color()</a>, these functions are for returning the information of the object in a <a href="http://www.cplusplus.com/reference/string/string/string/">std::string</a>. coulple of choices were made. We decided to use one super class. Drawable is this class. Everything that can be drawn on the screen is considerd a drawable. We decided to give no actions, because not every drawable is a moving object.</p>
<h1><a class="anchor" id="images"></a>
The images in the game</h1>
<p>All the images just in the game are shown as object of the image class. the image class has multiple function that can be used. the image class is a inherintance of the drawable class. Image uses also a override of the <a class="el" href="classdrawable.html#a4e49e2c1121704c83ce24c5f48dd910f" title="virtual draw function for a drawable ">drawable::draw()</a>. Furthermore the class contains an <a class="el" href="classimage__from__file.html#a43b0d6b11bf46827308e4e6cb7aa8579" title="set size ">image_from_file::set_size()</a> and an <a class="el" href="classimage__from__file.html#a868911f8d541af91290fb8dc56435cd2" title="set position ">image_from_file::set_position()</a> these functions are for setting a new size or position.Finally it contains a function for getting the global bounds called <a class="el" href="classimage__from__file.html#a971a591f906fa5c6e85b4e32cfc3d6a0" title="get objects floatrect ">image_from_file::getGlobalBounds()</a> and an <a class="el" href="classimage__from__file.html#a6561a7e8833e4ca84ba5a31e98802757" title="set the texture rectangle ">image_from_file::setTextureRect()</a> for setting a texture in the image also this function is beeing used for mirroring a image without position change. in the image class their were some choices to make. The function set_repeat is used to make sure you can only see background. When set_repeat is called and the size of the level is bigger then the background this function places multiple backgrounds next to eachother to fill the level size. For the <a class="el" href="classimage__from__file.html" title="create sprite on screen ">image_from_file</a> class we decided to throw an error when an image cannot be loaded. Sfml throws errors for these things asswell. But these errors are not catchable. The errors we throw can be caught and used to determine if the game should continue to run.</p>
<h1><a class="anchor" id="unicorn"></a>
Unicorn</h1>
<p>The unicorn and it's rainbow in the game can be created by creating an object of the <a class="el" href="classunicorn.html" title="class that is used to display and control the unicorn ">unicorn</a> class. Rainbow get's it's location by using the location of the unicorn in combination with the location of the window. The image of the unicorn and of the rainbow are created by the <a class="el" href="classimage__from__file.html" title="create sprite on screen ">image_from_file</a> class. the unicorn also uses the <a class="el" href="classphysics.html" title="Class with physics function. ">physics</a> class to create a more realistic jumping and falling motion. The class dus also inherrit <a class="el" href="classdrawable.html" title="class that is inherited by all objects that are drawable ">drawable</a>. Drawable comes with his predefined funtions that can be used by the unicorn due to the inherritance. The unicorn class also overrides the couple of abstract functions. These functions are <a class="el" href="classdrawable.html#a4e49e2c1121704c83ce24c5f48dd910f" title="virtual draw function for a drawable ">drawable::draw()</a>, <a class="el" href="classdrawable.html#ad0d3930c045cc6776aa2c3965be32491" title="Move function for a drawable. ">drawable::move()</a>, <a class="el" href="classdrawable.html#ac39691470b7874f5dec59efe649d3981" title="virtual draw function for a drawable ">drawable::jump()</a>, <a class="el" href="classdrawable.html#ae013ac0be47538be9ce885d6642daf73" title="virtual getGlobalBounds function ">drawable::getGlobalBounds()</a>, <a class="el" href="classdrawable.html#a715df01a318331e5611a2b0ad30109ff" title="check and execute actions ">drawable::run_actions()</a>, <a class="el" href="classdrawable.html#abbc6e0089d502ba48c3fcb9c96e3966e" title="check for collisions ">drawable::check_for_collisions</a>. The <a class="el" href="classunicorn.html#a570c34d5669a8d2a61bdc1481e6f9dee" title="function that draws the image ">unicorn::draw()</a> function first checks if the direction the unicorn is facing is correct. If it is not, the unicorn is turned around. After that either the <a class="el" href="classphysics.html#aaf1c57aa6e35b9c83ccbfdfa8c18468c" title="The working function for jumping. ">physics::jumping()</a> function is called to move the unicorn up or the <a class="el" href="classphysics.html#acca1ee2fb8b760b6e4ee61ae7c2ee3da" title="the working function that contains the gavity. ">physics::falling()</a> function is called to move the unicorn down. There is one exception to both, the unicorn dus not fall if he is on the ground and the unicorn also dus not go up when something is above him. The <a class="el" href="classunicorn.html#a162f200a68342f7bc0baaf17c8cf3f9f" title="function that moves image object with a certian delta ">unicorn::move()</a> function moves the unicorn right and left unless there is a collision on the side he is trying to move to. The <a class="el" href="classunicorn.html#a07d5ca4e66632c0e871221a27146805a" title="let the unicorn jump ">unicorn::jump()</a> function sets the counter for jumping to 25 so it can be counted down to 3 in the draw function. These values seemed to give us the most realistic jumping effect This counter is used to calculate the speed with wich the unicorn goes up in the <a class="el" href="classphysics.html#aaf1c57aa6e35b9c83ccbfdfa8c18468c" title="The working function for jumping. ">physics::jumping()</a> function. It dus not do this when he is not on the ground or when the counter is not 0. This way dubble jumping is impossible. <a class="el" href="classunicorn.html#a1bac09fc59b04f14f5a093bc4daa04da" title="function that gets the boundingbox of the image ">unicorn::getGlobalBounds()</a> returns the global bounds of the image. These global bounds can be used for collision detection. The <a class="el" href="classunicorn.html#aadb47a9981c46d6add8704074df117df" title="functions that runs through all actions related to the unicorn ">unicorn::run_actions()</a> function goes through the list of actions. It calls the <a class="el" href="classaction.html#a92c003677656b5b3e6e58b19376e6b04" title="operator() ">action::operator()()</a> from the <a class="el" href="classaction.html" title="actions that a charater can do ">action</a> class on all the actions and the rest is handled by the operator() function. for the unicorn we made some choices. In the draw function from the unicorn is a lot of code. This is to make sure all things happen every iteration.</p>
<h1><a class="anchor" id="wall"></a>
The walls of the game</h1>
<p>The wall creates a rectangle on the screen on specified position and with a specified size. The color of the wall can also be set to an initial color. The class inherrits <a class="el" href="classdrawable.html" title="class that is inherited by all objects that are drawable ">drawable</a> to be able to use all its functionality. The functions from drawable that are redefined here are: <a class="el" href="classdrawable.html#a4e49e2c1121704c83ce24c5f48dd910f" title="virtual draw function for a drawable ">drawable::draw()</a>, <a class="el" href="classdrawable.html#ae013ac0be47538be9ce885d6642daf73" title="virtual getGlobalBounds function ">drawable::getGlobalBounds()</a>, <a class="el" href="classdrawable.html#a2ed0f8bb53f33477f7722efa7bb24583" title="object information as string ">drawable::object_information()</a>. The <a class="el" href="classwall.html#aa25b8377e1d9a209fabd2271294f05d0" title="Draw function for the wall. ">wall::draw()</a> function draws the object and sets the color and position. The <a class="el" href="classwall.html#a317a464c879cfdf9464bd6f1b62d9101" title="Function that gives de global bounds. ">wall::getGlobalBounds()</a> function returns the global bounds of the rectangle. The <a class="el" href="classwall.html#aab1de4f144f176b134a967ba08747932" title="Funtion that returns object information. ">wall::object_information()</a> function returns the information of the object as <a href="http://www.cplusplus.com/reference/string/string/string/">std::string</a>. This includes the size and the color. The rest of the information comes from the <a class="el" href="classdrawable.html#a2ed0f8bb53f33477f7722efa7bb24583" title="object information as string ">drawable::object_information()</a> function.</p>
<h1><a class="anchor" id="actions"></a>
The actions for the different objects</h1>
<p>The <a class="el" href="classaction.html" title="actions that a charater can do ">action</a> class is a class made for handeling in game actions it contains couple of different constructors that are made for different actions. for using keybaord and mousse there are two different constructors and there is a constructor that can be used in a template way where if parameter 1 gives true the function given in parameter number 2 will be runt. in the action class there needed to maake some choices. This action class can be used to make arrays, or single objects, that can be executed by the program. There are different constructors to make objects. sf::Mouse and sf::Keyboard buttons can be used to check if they are pressed.</p>
<h1><a class="anchor" id="animation"></a>
the animation in the game</h1>
<p>the animation class is the class that makes the objects in the game have animations like walking around and loop when jumping the way the animations work is a big picture with multiple states on it in which the program will loop in and making the walk movement or other movement in which the sheet is set. One sheet contains multiple rows with multiple lines each line is one animation and some animations are made bij using <a href="https://www.sfml-dev.org/documentation/2.0/classsf_1_1Sprite.php">sf::sprite</a> functions like<a href="https://www.sfml-dev.org/documentation/2.0/classsf_1_1Transformable.php#a32baf2bf1a74699b03bf8c95030a38ed">sf::sprite::setRotation</a> and<a href="https://www.sfml-dev.org/documentation/2.0/classsf_1_1Transformable.php#aa93a835ffbf3bee2098dfbbc695a7f05">sf::sprite::setOrigin</a> for the jump. By resetting the origin to position 0.5*size the rotation will be in the middle of the certain object. And after that replacing the origin to the position which makes it turn around the mid without teleport like bugs. <a class="el" href="classanimation.html#af213ade7eb27bba8337ec6223c73f945" title="This function for animations. ">animation::movement()</a> is the real animation function of the animation class with in this function we made some choices like. The float row_a can be used to decide which animation to use. While walking to the left the function wil loop in the left-walking animation from the spreadsheet. While jumping the animation will be created with the rotate function of sfml. Before rotating the image, the rotate position is moved from the upper-left corner to the middle of the picture.</p>
<h1><a class="anchor" id="physics"></a>
The game's physics</h1>
<p>The action class is a class that contains the needed functions for making movement in the game feel natural. for jumping there is the <a class="el" href="classphysics.html#aaf1c57aa6e35b9c83ccbfdfa8c18468c" title="The working function for jumping. ">physics::jumping()</a> function and for the grafity there is the <a class="el" href="classphysics.html#acca1ee2fb8b760b6e4ee61ae7c2ee3da" title="the working function that contains the gavity. ">physics::falling()</a> function. choices that are made are For jumping the unicorn moves 150 pixels upward. This happends in 25 for-loop iterations. The first iteration moves the unicorn 12 pixels after that the amount of pixels becomes exponentially less, this makes that the unicorn slow down at the top of his jump. Falling works the same way only after 40 for-loop iterations the amount of pixels per iteration is locked. This happens to make sure the unicorn desn't fall to fast where it would move through things.</p>
<h1><a class="anchor" id="background"></a>
The background of the game</h1>
<p>The background of the game. the background creates a sprite that is covered troughout the gamefield creating a background for the game. the background is een inheratance of the <a class="el" href="classdrawable.html" title="class that is inherited by all objects that are drawable ">drawable</a> class and uses the <a class="el" href="classdrawable.html#a4e49e2c1121704c83ce24c5f48dd910f" title="virtual draw function for a drawable ">drawable::draw()</a> function for drawing the background. the background class contains a image object where the background is in.</p>
<h1><a class="anchor" id="camera"></a>
The player folowing camera</h1>
<p>The camera class has one thing to do and has also only one function and that is following a object of the <a class="el" href="classunicorn.html" title="class that is used to display and control the unicorn ">unicorn</a> class.</p>
<h1><a class="anchor" id="sound"></a>
The sound in the games</h1>
<p>the soundtrack class is the class that handles the background music in this class is set the sound file by setting the music in the constructor and playing it by the playmusic function. Choices that where made are. To play sounds over the normal the sound already in the background. We pause the background-music and play the sound, while playing the sound we also resume the background-music. While we wanted to play a sf::Music item and a sf::Sound item at the same time, sfml didn't allow that.</p>
<h1><a class="anchor" id="base_level"></a>
The level boundary's</h1>
<p>Every level gets level boundary's. These boundary's are based on the level size read by the <a class="el" href="classfactory.html" title="Factory for reading in levels. ">factory</a> from the level files. These boundary's are made transparent. They are also created with a offset to make sure the borders are not in the upper left corner of the background. This way you do not see a partially black background. These level boundary's can be put into a objects vector by calling the <a class="el" href="classbase__level.html#a3b2da28cf45cad434103e81ee6c4538d" title="Put walls in the walls vector. ">base_level::push_back_borders()</a> function from the class and giving it the vector you want to put them in as parameter. for <a class="el" href="classbase__level.html" title="level border creation class ">base_level</a> class we made some choises. the base level class sets the box around a level. We intentionally didn't put the borders on position 0,0 because that would mean the user could see parts black screen. Because of the offset used</p>
<h1><a class="anchor" id="factory"></a>
Reading files with the factory</h1>
<p>The factory can be used to read out level files. An example of a level file is the following:</p>
<p>SPAWN (1030,1500).<br />
 LEVEL_SIZE (4000,3350).<br />
 WALL (1020.000000,2000.000000) (100.000000,20.000000) green grass.png.<br />
 WALL (1499.824341,2133.414062) (100.000000,20.000000) green grass.png</p>
<p>The first two lines are always neccesary because the level wil not have a correct size or a spawn point without them. The rest can be customized to what level you want. In The factory there are 6 functions. The first one is called <a class="el" href="classfactory.html#a9e164a8fbb65188de99c39d55d7cc384" title="Change the input. ">factory::change_input_to()</a> and is used to change the input file. If a file is already open it closes that file first. The second and third are used to read lines from the input file. They are called <a class="el" href="classfactory.html#a82385866bc910c1b3a3e82d56487dd24" title="Read one line from the filestream. ">factory::read_line()</a> and <a class="el" href="classfactory.html#afb2fad4ac9b0f39b1bfc3f3fc8d218b6" title="Read multiple objects. ">factory::objects_from_file()</a>. The read line function reads a single line and returnes an <a class="el" href="typedefs_8hpp.html#aab5add95f06d2ba25dbfed8eb07274fa" title="std::shared_ptr to a drawable object ">object_ptr</a> to the newly created object or an error of different types if something went wrong. The objects from file function handles all the errors and puts the objects in an <a class="el" href="typedefs_8hpp.html#a6c0fdb1dfd0c34dbbdbb5dcd3c608b07" title="std::vector with object_ptr objects ">objects_vector</a>. This vector is returned. The next function is called <a class="el" href="classfactory.html#af17f2a44d75cf8ccf712384341c2fcde" title="Write information to file. ">factory::write_information_to_file()</a> and writes all the information about objects to a file. This repeatedly calles the <a class="el" href="classdrawable.html#a2ed0f8bb53f33477f7722efa7bb24583" title="object information as string ">drawable::object_information()</a> function after the spawn and level size ar already put into the file. The last two functions are for getting the level size and the spawn location from the factory. The names for these functions are <a class="el" href="classfactory.html#a3c3a039b8f76a947267dbe659166550b" title="Get spawn location. ">factory::get_spawn()</a> and <a class="el" href="classfactory.html#af9bb026273b34fc032ca5ac73d457611" title="Get the level size. ">factory::get_level_size()</a>. in the factory we made some compromises . For the factory class we decided to read the file in a different function than reading a single line. This helps when throwing exceptions. When an exception is thrown, the program stops with loading the file. We use the <a class="el" href="classfile__management.html" title="file manager for the save-files ">file_management</a> class to manage which files are open and closed.</p>
<h1><a class="anchor" id="bullet"></a>
Shooting feature</h1>
<p>The bullet class is used to move a <a class="el" href="classimage__from__file.html" title="create sprite on screen ">image_from_file</a> object (in this game Nyan-Cat.png) a amount of spots. When the bullet animation collides (this is checked with <a class="el" href="classbullet.html#ab7e5c677bbd642df24a2251bb58249b7" title="function that checks collision with pointer ">bullet::collision()</a>) with either a wall or a mob the bullet is reset and not drawn until it is fired agian. With <a class="el" href="classunicorn.html#af448a3fa5fc5f09254b50afa151ce42b" title="function that shoots bullet ">unicorn::shoot()</a> the bullet is activated. In unicorn we made the choice to use one bullet object, this effects in the fact that you can only fire one bullet at the time. This is mainly because of memory purposes, if you want to fire multiple bullets you should have more bullet objects, this can take a lot of memory of the computer Shoot also has a shoot_timeout, this variable is used to give the bullet a distance that it can travel if it doesn't hit anything, when it does hit something(a wall or a mob) the shoot_timeout is reset to 0, and the user can fire the bullet again.</p>
<h1><a class="anchor" id="mob"></a>
Enemy creatures</h1>
<p>The mob class is used to display an enemy. When <a class="el" href="classmob.html#ac524dd40986df00721239b66c552437e" title="constructor to initialize mob ">mob::mob()</a> is called the mob is always alive. When <a class="el" href="classmob.html#ae892b3ce84f4aa16411b385abb5410c8" title="function that sets boolean ">mob::die()</a> is called the mob dies and the variable alive is set to false , this means it isn't drawn anymore and has a empty global bounds . The global bounds is empty to make sure the bullet goes through the mob when it has died. <a class="el" href="classmob.html#a3bce6c06653881f8be86fbc60a2b67cb" title="function that sets boolean ">mob::revive()</a> can be used to set the variable alive to true For the image class there were some choices to make. The mob class contains a boolean that indicates if the mob is alive. When the mob is alive, the mob is drawn. When the mob is not alive it isn't drawn and also has a 0 by 0 global bounds. This makes it possible to walk on the place where the mob is actually standing without losing lives. We took in consideration to destroy the object when it dies, but that would mean we had to load all mobs, that died, in agian when reseting a level</p>
<h1><a class="anchor" id="menu"></a>
The menu's</h1>
<p>The main menu consists mainly of 2 parts. First , the background image. This is an object of the <a class="el" href="classbackground.html" title="Class that draws a background. ">background</a> class. This sets the background sprite with the specified image. Second, the buttons that make up the menu. The main menu consists of three buttons, these are #Button objects. Together they make up the visual aspect of the menu. The clickable part is handled in <a class="el" href="classmenu.html#a06744d58a2aad693d3637d0485aa7984" title="Function that handles the pushable part of the button. ">menu::select()</a>, where the collision detection <a href="https://www.sfml-dev.org/documentation/2.0/classsf_1_1Rect.php#aa8a5364c84de6dd5299f833b54e31ef1 ">standard SFML Rect::contains()</a> triggers if the button is clicked with the cursor ( left mouse button ).</p>
<h1><a class="anchor" id="Button"></a>
The buttons</h1>
<p>The buttons are made specifically tailored for our game. The buttons are all customizable, background is easy to change as is the font.</p>
<p>All the math in this class is done to make sure the buttons are aligned in the middle of the screen, regardless of resolution. However, SFML does not have a native rescale of pictures in sprites. Which means that the background of the buttons will be completely distorted in some resolutions. Also, a lot of this math could be moved to the <a class="el" href="classmenu.html" title="Creates a menu with up to 3 buttons. ">menu</a> class, which would make the <a class="el" href="classbutton.html" title="Creates a button at a specific place on the screen. ">button</a> class more re-useable.</p>
<h1><a class="anchor" id="menu_management"></a>
menu_management</h1>
<p>This class is used to manage the different menu's in the game. <a class="el" href="classmenu__management.html#aad6e975e03cab2478f3ebec8da7eaf7d" title="function that displays start_menu ">menu_management::display_start_game()</a> , <a class="el" href="classmenu__management.html#ab7aa6674e3428604073af06efe5aa791" title="function that displays pause_menu ">menu_management::display_pause_game()</a> , <a class="el" href="classmenu__management.html#ac64c1eace3d955be8623a1129597dc54" title="function that displays the save_file_menu ">menu_management::display_save_file_menu()</a> are functions that can be used to display there respective menu. The function <a class="el" href="classmenu__management.html#a92d22f059d33ccc5c3ae485804fd5fbb" title="function that is used to start the game ">menu_management::start_game()</a> combines the start_menu and the save_file menu. This function returns the path to the level selected by the user. In the menu manager their where a couple of choices to make. The option to go with a <a class="el" href="classmenu__management.html" title="manager of all menu&#39;s in game ">menu_management</a> class instead of putting it in the main, was taken because the looks of it. Otherwise it makes the main already fuller that is needs to be.</p>
<h1><a class="anchor" id="file_management"></a>
file_management</h1>
<p>This class is used to manage the different files for the game. With the function <a class="el" href="classfile__management.html#a6c3f90ce958156adea878510097d64ef" title="function that loads input from file ">file_management::get_files()</a> you can get the information from the current file used as input. With <a class="el" href="classfile__management.html#a090d9aba4dd5a795428ccbfe8d4037e6" title="function that changes input that is used for information ">file_management::set_input()</a> you can change the input file. With the function <a class="el" href="classfile__management.html#a97eda13bca5dbe703663bf81f83a77a0" title="function that rerturns menu-object ">file_management::make_save_file_menu()</a> you can make a menu-object that gives the right amount of save files in buttons for the user to click. The function <a class="el" href="classfile__management.html#a79e6ae7cec63aa959d7d0730d6ffa5a3" title="function that saves game ">file_management::save_game()</a> can be used to save the game in the current save_game file. in the file manager their where some choises to made We are using a management class for the files because it leaves the main a little bit cleaner. Otherwise the files had to be opend and closed in the main. It also gives easy calls in the main to go tho a next level or save a game.</p>
<h1><a class="anchor" id="cutscene1"></a>
cutscene1 and textbox</h1>
<p>The cut scenes are built from multiple <a class="el" href="classtextbox.html" title="Creates a box with text and a headshot. ">textbox</a> objects and <a class="el" href="classimage__from__file.html" title="create sprite on screen ">image_from_file</a> objects. They are slightly hardcoded. There are multiple reasons for this. The most important one was time. These scenes had a very low priority in the project and only get used once in the game. They don’t really need to be changed, the only thing you might want to change is the text which is very easy to do. The cut scenes are build from multiple smaller functions to keep some overview of the class. The <a class="el" href="classcutscene1.html#af4c8e7ddc01274a70da482e1d7f56a14" title="Draws the opening scene. ">cutscene1::play_scene()</a> function contains all these functions, the proper sfml::sleep() periods and the window::clear() and window::display() functions. The cyan island cut scene is made in the exact same way. The textboxes are made in proportion to the window size. The given string is displayed and the images are shown. Some minor math is done to ensure that the text is positioned at the right place. Not everything can completely scale on all resolutions, this was not fixable in the given timeframe. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
